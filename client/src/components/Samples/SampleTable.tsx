import { DataGrid, GridColDef, GridRowId, GridToolbar, GridValueGetterParams } from '@mui/x-data-grid';
import { GridToolbarContainer } from '@mui/x-data-grid/components';

import { Button, MenuItem, Paper, Select, SelectChangeEvent } from "@mui/material";

import RefreshIcon from '@mui/icons-material/Refresh';
import DeleteIcon from '@mui/icons-material/Delete';
import NoteAddIcon from '@mui/icons-material/NoteAdd';
import HistoryIcon from '@mui/icons-material/History';

import { AxiosResponse } from "axios";

import { useEffect, useState } from "react";

import { useSelector } from "react-redux";

import * as api from '../../api/index';
import { GeneralSample, Printer } from "../../api/types";

import { Link } from "react-router-dom";

import "./styles.css";

/**
 * Given an array of samples, will group those with the same audit id, and filter the ones
 * with the highest audit_number.
 * @param allSamples The samples to be filtered
 * @returns An array of the newest samples and an object with keys as the unique audit_id and values being an array of all samples with that audit_id
 */
function filterNewestSamples(allSamples: GeneralSample[]): { newestSamples: GeneralSample[], auditGroups: AuditGroups } {
    const auditGroups: AuditGroups = {};
    const newestSamples: GeneralSample[] = [];

    /**
     * Generates an object with keys as the unique audit_id and values
     * being an array of all samples with that audit_id
     */
    for (const sample of allSamples) {
        if (!auditGroups[sample.audit_id]) {
            auditGroups[sample.audit_id] = [sample];
        } else {
            auditGroups[sample.audit_id].push(sample);
        }
    }

    /**
     * Now we go through that object and for each unique audit_id
     * we find the sample with the max audit_number (aka most recent sample)
     * and add it to `newestSamples`
     */
    for (const key of Object.keys(auditGroups)) {
        // Reduce function goes through all the samples in an audit group and finds the one with the highest audit_number (aka most recent sample)
        const newestSample: GeneralSample = auditGroups[key].reduce((max: GeneralSample, value: GeneralSample) => {
            return value.audit_number > max.audit_number ? value : max;
        })
        newestSamples.push(newestSample);
    }

    return { newestSamples, auditGroups };
}

type AuditGroups = { [key: GeneralSample["audit_id"]]: GeneralSample[] }

interface SampleTableProps {
    /**
     * What key to select from the redux state
     * * useSelector((state) => state[selector])
     * 
     */
    selector: string;
    
    /**
     * What should happen when the refresh button is clicked
     * * This is usually a dispatch to the redux store
     */
    onRefresh?: () => void;

    /**
     * What should happen when the delete button is clicked
     * * Generally going to call an api route to delete each sample
     */
    onDelete?: (selected: GeneralSample[]) => Promise<void>;

    /**
     * Given an array of selected samples, generate the labels, 
     * and return an array of base64 strings
     * @param selected The current samples selected in the data grid
     * @returns An array of base64 strings
     */
    onGenerateLabels?: <T extends GeneralSample>(selected: T[]) => Promise<string[]>;

    /**
     * Function encapsulating an api call to the server to update a sample
     * @param sample The sample to be updated
     * @returns The updated sample with its new qr_code_key as an axios response
     */
    updateSample?: (sample: GeneralSample) => Promise<AxiosResponse<GeneralSample, any>>

    /**
     * Overrides selected samples from redux store.
     * Most likely use case is with an audit table.
     */
    overrideSamples?: GeneralSample[];

    /**
     * Whether we are showing an audit table or not. An audit table will have certain 
     * features removed such as editing, generating labels, and deleting samples.
     */
    isAuditTable?: boolean;

    auditLink?: (audit_id: string) => string;

    /**
     * Override the default column definitions which are generated by analysing the structure
     * of data returned by redux store.
     */
    overrideGridColDefs?: GridColDef[];
}

const SampleTable: React.FC<SampleTableProps> = ({
    selector,
    onRefresh,
    onGenerateLabels,
    onDelete,
    updateSample,
    overrideSamples,
    isAuditTable,
    auditLink,
    overrideGridColDefs,
}) => {
    /**
     * Stores the base64 label images generated by `onGenerateLabels`
     */
    const [labelImages, setLabelImages] = useState<string[]>([]);

    /**
     * This stores the most recent samples filtered by audit_id and audit_number.
     * This only shows unique sample (i.e. unique audit_id). These are the samples
     * that are shown in the data grid.
     */
    const [viewableSamples, setViewableSamples] = useState<GeneralSample[]>([]);

    /**
     * Stores the currently selected samples. These are the samples that are passed to 
     * the `onGenerateLabels` function.
     */
    const [selectedSamples, setSelectedSamples] = useState<GeneralSample[]>([]);    

    /**
     * The currently selected printer name. We can search the printers returned by
     * the redux store to find the full printer details (ip, name, model, location)
     */
    const [printer, setPrinter] = useState('None');

    /**
     * The current page size. This is used to determine how many samples to show on each page
     */
    const [pageSize, setPageSize] = useState(10);

    /**
     * If we are given `overrideSamples` use those, 
     * otherwise, select our samples from the redux store.
     * * We must call useSelector initially due to reacts rule of hooks
     */
    var samples: GeneralSample[] = useSelector((state: any) => state[selector]);
    
    if (overrideSamples !== undefined) {
        samples = overrideSamples;
    }
    
    /**
     * Now we will select all the printers from the redux store.
     */
    const printers: Printer[] = useSelector((state: any) => state.printers);

    /**
     * Assuming a change in the samples array, this function will filter
     * out the newest samples and set those as viewable. If this is an audit 
     * table it will set the viewable samples to be the same as the samples array.
     * Therefore if the property `isAuditTable` is true, then `overrideSamples` property
     * should be provided.
     */
    const updateViewableSamples = () => {
        if (isAuditTable) {
            setViewableSamples(samples);
        } else {
            const { newestSamples } = filterNewestSamples(samples);
            setViewableSamples(newestSamples);
        }
    }

    /** 
     * As samples are loaded in via redux useSelector from above we update our viewable samples 
     */
    useEffect(() => {
        updateViewableSamples();
    }, [samples])

    /** ----- on functions ----- */

    /**
     * Handles the printing of the labels.
     */
    const onPrintLabels = async () => {
        const device: Printer = printers.find((p: Printer) => p.name === printer)!;

        for (let i = labelImages.length - 1; i >= 0; i--) {
            const image: string = labelImages.pop()!;
            await api.printLabel(image, device);
            setLabelImages([...(labelImages ?? [])]);
        }
    }

    /**
     * When a printer is selected from the dropdown, this function will be called.
     * The dropdown is only visible after labels have been generated.
     * @param event The event that triggered this function
     */
    const onPrinterChange = (event: SelectChangeEvent<string>) => {
        setPrinter(event.target.value);
    }

    /**
     * Handles the editing process and makes the relevant api call to update the sample.
     * @param newRow The new row data
     * @param oldRow The old row data
     * @returns The data to display in the data grid
     */
    const onSampleRowEdit = async (newRow: GeneralSample, oldRow: GeneralSample): Promise<GeneralSample> => {
        const prismaDate = (dstring: string) => new Date(dstring).toISOString().split('T')[0];
        
        const { data } = await updateSample!({
            ...newRow,
            date_entered: prismaDate(newRow.date_entered),
            date_modified: prismaDate(newRow.date_modified),
            expiration_date: prismaDate(newRow.expiration_date),
        });

        samples.push(data);

        updateViewableSamples();

        return data;
    }

    /**
     * Fired when a new sample (or all) was selected in data grid
     * @param newSelection The new selection of samples
     */
    const onSelectionChange = (newSelection: GridRowId[]) => {
        const samples: GeneralSample[] = []
        newSelection.forEach((qr_code_key: GridRowId) => {
            samples.push(viewableSamples.find((sample: GeneralSample) => sample.qr_code_key === qr_code_key)!);
        });
        setSelectedSamples(samples);
    }

    /** ---------- end --------- */

    /**
     * Custom toolbar for the data grid to add a few buttons
     */
    const CustomToolbar: React.FC = () => {
        const onGenerateLabelsClick = async () => {
            setLabelImages(await onGenerateLabels!(selectedSamples));
        }

        return (
            <GridToolbarContainer>
                <GridToolbar />
                
                <Button 
                    startIcon={<NoteAddIcon />} 
                    disabled={selectedSamples.length == 0} 
                    onClick={onGenerateLabelsClick}
                >
                    Generate Label(s)
                </Button>

                <Button 
                    startIcon={<DeleteIcon />} 
                    disabled={selectedSamples.length == 0} 
                    onClick={() => { onDelete!(selectedSamples); }}
                >
                    Delete Sample(s)
                </Button>
                
                <Button 
                    startIcon={<HistoryIcon />} 
                    disabled={selectedSamples.length != 1}
                >
                    <Link
                        to={auditLink!(selectedSamples[0]?.audit_id)}
                        style={{textDecoration: 'none', color: 'inherit'}}
                    >
                        View Audit Table    
                    </Link>
                </Button>

                <Button 
                    startIcon={<RefreshIcon />} 
                    onClick={onRefresh}
                >
                    Refresh Samples
                </Button>
            </GridToolbarContainer>
        )
    }

    const dateGetter = <K extends keyof GeneralSample>(sample: GeneralSample, key: K) => {
        const input: string = sample[key] as string;
        const split = input.split("-");
        const year = split[0];
        const month = split[1];
        const day = split[2];
        const date = `${month}/${day}/${year}`;
        // some dates had some sort of sequence like {month}/{day}T00:00:00Z/{year}
        // so we remove that
        var out: string = date.substring(0, date.indexOf('T')) + date.substring(date.indexOf('Z'), date.length);       
        return new Date(out);
    } 

    const columns: GridColDef[] = [
        { 
            field: 'qr_code_key', 
            headerName: 'QR Code Key', 
            width: 150,
            sortable: false,
        },
        ...(overrideGridColDefs ?? []),
        { 
            field: 'date_entered', 
            headerName: 'Date Entered', 
            flex: 1,
            type: 'date',
            sortable: true,
            editable: true,
            valueGetter: (params: GridValueGetterParams<any, GeneralSample>) => dateGetter(params.row, 'date_entered')
        },
        { 
            field: 'date_modified', 
            headerName: 'Date Modified', 
            type: 'date',
            flex: 1,
            sortable: true,
            editable: true,
            valueGetter: (params: GridValueGetterParams<any, GeneralSample>) => dateGetter(params.row, 'date_modified')
        },
        { 
            field: 'expiration_date', 
            headerName: 'Expiration Date',
            flex: 1,
            type: 'date',
            sortable: true,
            editable: true,
            valueGetter: (params: GridValueGetterParams<any, GeneralSample>) => dateGetter(params.row, 'expiration_date')
        },
    ];

    return (
        <>
        <div className='data-grid-container'>
            <DataGrid className='data-grid'
                experimentalFeatures={{ newEditingApi: true }}
                rows={viewableSamples}
                columns={columns}
                pageSize={pageSize}
                rowsPerPageOptions={[10, 25, 50]}
                getRowId={(sample: GeneralSample) => sample.qr_code_key}
                components={{ Toolbar: isAuditTable ? GridToolbar : CustomToolbar }}
                isCellEditable={(params) => params.field !== 'qr_code_key' && params.field != 'date_entered' && !isAuditTable}
                disableSelectionOnClick
                checkboxSelection
                onSelectionModelChange={onSelectionChange}
                onPageSizeChange={(size) => setPageSize(size)}
                editMode='row'
                processRowUpdate={onSampleRowEdit}
                getRowClassName={(params) => {
                    return `data-grid-row${new Date(params.row.expiration_date) < new Date(Date.now()) ? '-expired' : ''}`;
                }}
            />
        </div>
        
        {
            labelImages.length > 0 ? (
                <>
                    <Paper className="img-label-container">
                        {
                            labelImages.map((labelImage: string, i) =>
                                <img className="img-label" key={`${i}`} src={`data:image/png;base64,${labelImage}`} alt="Label"/>
                            )
                        }
                    </Paper>
                    <span>
                        <Select
                            value={printer}
                            label="Printer"
                            onChange={onPrinterChange}
                        >
                            <MenuItem value='None'>None</MenuItem>
                            {
                                printers.map((printer: Printer, i) =>
                                    <MenuItem key={`${i}`} value={printer.name}>{printer.name}</MenuItem>
                                )
                            }
                        </Select>
                        {
                            printer !== 'None' ? (
                                <Button onClick={onPrintLabels} >Print Labels</Button>
                            ) : (
                                <></>
                            )
                        }
                    </span>
                </>
            ) : (
                <></>
            )
        }
        </>
    );
}

export default SampleTable;